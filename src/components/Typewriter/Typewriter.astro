---
import './_typewriter.scss';

const {
    textArray = [],
    id: propId,
    align = 'left',
    loopAll = false, // ÚJ: az egész oldal Typewriter-sorozata ismétlődjön?
    loopAllDelay = 1000, // ÚJ: szünet a körök között (ms)
} = Astro.props;

// Egyedi azonosító minden példánynak
const uid = propId ?? `tw-${crypto.randomUUID?.() ?? Math.random().toString(36).slice(2)}`;
---

<div class="typewriter-wrap">
    <div class={`output ${align === 'center' ? 'align-center' : 'align-left'}`} id={`output-${uid}`} data-tw-id={uid}>
        <p></p>
    </div>
</div>

<script type="module" is:inline define:vars={{ textArray, uid, loopAll, loopAllDelay }}>
    // Globális vezérlő a sorba rendezéshez és a teljes kör ismétléséhez
    const TW = (function () {
        const g = typeof window !== 'undefined' ? window : {};
        // Queue a futtatandó példányoknak (aktuális kör)
        g.__twQueue = g.__twQueue || [];
        // A példányok "starter" függvényei (fix sorrendben, teljes kör ismétléséhez)
        g.__twStarters = g.__twStarters || [];
        g.__twRunning = g.__twRunning || false;
        g.__twLoopAll = g.__twLoopAll ?? false;
        g.__twLoopAllDelay = g.__twLoopAllDelay ?? 1000;

        function setLoopAll(val, delay) {
            g.__twLoopAll = !!val;
            if (typeof delay === 'number') g.__twLoopAllDelay = delay;
        }

        function runNext() {
            if (g.__twQueue.length > 0) {
                const fn = g.__twQueue.shift();
                fn();
            } else {
                // Kör vége
                if (g.__twLoopAll && g.__twStarters.length > 0) {
                    // Teljes kör újratöltése kis szünettel
                    setTimeout(() => {
                        // újra feltöltjük a queue-t az eredeti sorrendben
                        g.__twQueue.push(...g.__twStarters.map((fn) => fn));
                        runNext();
                    }, g.__twLoopAllDelay);
                } else {
                    g.__twRunning = false;
                }
            }
        }

        function enqueue(fn) {
            g.__twQueue.push(fn);
            if (!g.__twRunning) {
                g.__twRunning = true;
                runNext();
            }
        }

        function registerStarter(fn) {
            g.__twStarters.push(fn);
        }

        function done() {
            runNext();
        }

        return { enqueue, registerStarter, done, setLoopAll };
    })();

    window.addEventListener('DOMContentLoaded', () => {
        const output = document.getElementById(`output-${uid}`);
        if (!output || !Array.isArray(textArray) || textArray.length === 0) return;

        const eParagraph = output.querySelector('p');

        // Konfigurációk
        const speedForward = 100; // gépelés tempó
        const speedWait = 1000; // várakozás, mielőtt töröl
        const speedBackspace = 25; // törlés tempó
        const blinkPeriod = 500; // 0.5s: a CSS blink animáció periódusa
        if (typeof TW.setLoopAll === 'function') {
            TW.setLoopAll(loopAll, loopAllDelay);
        }

        // Egy példány futtatója (starter) — ezt tesszük be a queue-ba és a starters listába is
        const starter = () => {
            let i = 0,
                a = 0,
                isBackspacing = false;

            function typeWriter() {
                const aString = textArray[a];

                if (!isBackspacing) {
                    // Vége a jelenlegi üzenetnek → vár, majd töröl
                    if (i >= aString.length) {
                        isBackspacing = true;
                        setTimeout(typeWriter, speedWait);
                        return;
                    }

                    const ch = aString.charAt(i);

                    // PIPE: egymás utáni '|' jelek szünetet okoznak (a karakterek nem íródnak ki)
                    if (ch === '|') {
                        let pipes = 0;
                        while (aString.charAt(i + pipes) === '|') pipes++;
                        i += pipes; // átugorjuk a pipe-okat
                        if (!eParagraph.classList.contains('cursor')) eParagraph.classList.add('cursor');
                        setTimeout(typeWriter, pipes * blinkPeriod);
                        return;
                    }

                    // normál karakter
                    eParagraph.textContent += ch;
                    i++;
                    setTimeout(typeWriter, speedForward);
                } else {
                    // Törlés
                    if (eParagraph.textContent.length > 0) {
                        eParagraph.textContent = eParagraph.textContent.slice(0, -1);
                        setTimeout(typeWriter, speedBackspace);
                    } else {
                        // Következő üzenet ugyanebben a példányban
                        isBackspacing = false;
                        i = 0;
                        a = (a + 1) % textArray.length;

                        // Ha visszaértünk az elejére → példány teljesen kész
                        if (a === 0) {
                            eParagraph.classList.remove('cursor'); // kurzor le
                            TW.done(); // jöhet a következő példány
                            return;
                        }
                        setTimeout(typeWriter, 50);
                    }
                }
            }

            // Indítás: kurzor fel, tiszta tartalom
            eParagraph.textContent = '';
            eParagraph.classList.add('cursor');
            setTimeout(typeWriter, 300);
        };

        // Regisztráljuk ezt a startert a teljes körhöz és az első futtatáshoz is beállítjuk
        TW.registerStarter(starter);
        TW.enqueue(starter);
    });
</script>
